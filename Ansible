
- Configuration management is the process of handling changes to a system in a way that assures integrity over time,
typically involving tools and processes that facilitate automation and observability. 

- Types of Configuration management Approach:

-- Push Configuration Management Tools:
    Push configuration management tools initiate and push configuration changes from a central server or control node to the target systems. 
    The central server actively sends the updated configurations to the target systems. 

    - Here are the key characteristics of push-based configuration management:

    - Centralized Control: A central server or control node, often referred to as the configuration management server,
      is responsible for initiating and distributing configuration changes to the target systems.
    - Push Model: The configuration changes are pushed from the configuration management server to the target systems. 
      The server actively sends the updated configuration to the target systems.
    - Immediate Updates: The target systems receive and apply the configuration changes immediately upon receiving the push from the configuration management server.
    - Real-Time Interaction: Push-based configuration management typically involves real-time communication between the configuration management server and the target systems.
    - Agent-Based Approach: Push-based configuration management often relies on agents or client software installed on the target systems. 
      These agents establish communication with the configuration management server and receive configuration updates.

  -  Examples :

  - Puppet: Puppet is a widely used push-based configuration management tool. It uses a client-server architecture, where a Puppet server pushes configurations (defined as Puppet manifests) to Puppet agents running on target systems.
  - SaltStack: SaltStack is another popular push-based configuration management tool. It employs a master-minion architecture, where a Salt master pushes configurations (defined as Salt states) to Salt minions running on target systems.
  - Ansible (with Ansible Push Jobs): While Ansible is primarily pull-based, it also offers a push-based feature called Ansible Push Jobs. It allows administrators to push configurations to target systems using the Ansible control server.

-- Pull Configuration Management Tools:
    Pull configuration management tools, on the other hand, enable target systems to independently fetch configurations from a central repository or server when needed.
    The target systems periodically or on-demand request and retrieve the updated configurations. 

  - Here are the key characteristics of pull-based configuration management:

  - Decentralized Control: Configuration changes are stored in a central repository or server, but the target systems independently retrieve the changes when needed.
  - Pull Model: The target systems periodically or on-demand pull the updated configuration from the central repository or server. They actively fetch the configuration changes.
  - Delayed Updates: The target systems update their configuration only when they request and retrieve the updated configuration from the central server. 
    Changes are not applied immediately upon availability.
  - Scheduled or Triggered Retrieval: The target systems can be configured to retrieve the configuration changes periodically, 
    based on a schedule or triggered by specific events or conditions.
  - Agentless or Light Agents: Pull-based configuration management can be agentless, where target systems fetch 
    configuration changes using lightweight protocols like HTTP or SSH. Alternatively, some tools may employ lightweight agents to handle the retrieval process.

 -  Examples :

  - Chef: Chef supports both push and pull modes. In its pull-based mode, target systems (Chef clients) periodically fetch 
    configurations (defined as Chef cookbooks) from a central Chef server.
--------------------------------------------------------------------------

Ansible Overview :
  - Ansible is a agentless modern configuration management tool that facilitates the task of setting up and maintaining remote servers, storage, 
    networking, and software with a minimalist design intended to get users up and running quickly.
  - Users write Ansible provisioning scripts in YAML, a user-friendly data serialization standard that is not tied to 
    any particular programming language. This enables users to create sophisticated provisioning scripts more intuitively compared to similar tools in the same category.
  - Ansible doesnâ€™t require any special software to be installed on the nodes that will be managed with this tool.
    A control machine is set up with the Ansible software, which then communicates with the nodes via standard SSH on linux and vinrm on windows.
  - It is push based tool.

Control node : where ansible is installd
Manage node : on which action are perform by ansible

install link : https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html

Inventory file :  it  defines the hosts and groups of hosts so you can run automation tasks on multiple hosts at the same time.
  - you can create group of manage nodes in inventory
      [groupname]
      Manage node
      Manage node

ad hoc commands :
  - An Ansible ad hoc command uses the /usr/bin/ansible command-line tool to automate a single task on one or more managed nodes.
  - ad hoc commands are quick and easy, but they are not reusable.
  - This cmd are not used for configuration management and deployment , because this are for one time use.
  - In ad-hoc commands there is no idempotency.   (means they overwrites)
  - ad hoc are used to reboot servers, copy files, manage packages and users,etc.

- link : https://docs.ansible.com/ansible/latest/command_guide/intro_adhoc.html

- syntax : $ ansible [pattern] -m [module] -a "[module options]"

- command to list hosts
	$ ansible all --list-hosts
	$ ansible demo --list-hosts    -- demo is groupname
	$ ansible demo[0] --list-hosts   --   first node is starts from 0

-a : argument   (to perform cmd/task written in " " )
-b : become   (for giving sudo permission)

    $ ansible all -a "ls -a"
    $ ansible demo -a "who"
    $ ansible demo -a "sudo apt install git -y"
    $ ansible demo -a "sudo apt remove git -y"
    $ ansible demo -ba "apt remove git -y"

- Ansible modules (-m):
    - Ansible module is a small program that performs actions on a local machine or remote host.
    - They can be executed directly from the command line or included in playbooks. 
    Modules are the building blocks of automation and can manage system resources, 
    install packages, manipulate files, and more.
   - the default location for module is inventery file, path /etc/ansible/hosts.
   - modules are writen in yaml format.

link :  https://docs.ansible.com/ansible/2.8/user_guide/modules.html

-m : module

pkg = httpd/git    -- package name you want to install/remove

state 
state=present    -- for installing package
state=absent     -- for removing package
state=latest     -- for updating package

$ ansible demo -b -m apt -a "pkg=git state=present"     -- install package
$ ansible demo -b -m apt -a "pkg=git state=absent"      -- remove package 
$ ansible demo -b -m service -a "name=ssh state=started"    -- start service
$ ansible demo -b -m user -a "name=jitu"                  -- create user
$ ansible demo -b -m copy -a "src=anime dest=/home/ansible"    -- copy file/dir

$ ansible demo[0] -m setup
$ ansible demo[0] -m setup -a "filter=*ip*"






- Ansible Roles : 
  - Ansible Roles provide a well-defined framework and structure for setting your tasks, variables, handlers, 
    metadata, templates, and other files. They enable us to reuse and share our Ansible code efficiently.
  - we can reference and call them in our playbooks with just a few lines of code while we can reuse the 
    same roles for many projects without the need to duplicate our code.
  - create role syntax : ansible-galaxy init <your_role_name>

- Components of an Ansible Role:

  - defaults : Includes default values for variables of the role. 
  - files  : Contains static and custom files that the role uses to perform various tasks.
  - handlers : A set of handlers that are triggered by tasks of the role. 
  - meta : Includes metadata information for the role, its dependencies, the author, license, available platform, etc.
  - tasks : A list of tasks to be executed by the role. 
  - templates : Contains Jinja2 template files used by tasks of the role. 
  - tests : Includes configuration files related to role testing.
  - vars : Contains variables defined for the role. 


- Why Use Ansible Roles?

  - Modularity : Roles allow you to break down complex playbooks into smaller, reusable components.
    Each role handles a specific part of the configuration or setup.

  - Reusability : Once created, roles can be reused across different playbooks and projects.
    This saves time and effort in writing redundant code.

  - Maintainability : By organizing related tasks into roles, it becomes easier to manage and maintain the code.
    Changes can be made in one place and applied consistently wherever the role is used.

  - Readability : Roles make playbooks cleaner and easier to read by abstracting away the details into logically named roles.

  - Collaboration : Roles facilitate collaboration among team members by allowing them to work on different parts of the infrastructure independently.

  - Consistency : Using roles ensures that the same setup and configuration procedures are applied 
    uniformly across multiple environments, reducing the risk of configuration drift.






